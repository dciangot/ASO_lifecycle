#!/usr/bin/env perl

# ptest.pl -- test driver for perf_test.pl
#
# this is to be installed on each test host and should be in default
# command path
#
# the ideal environment is to have all test hosts share a file system
# that has ptest.pl installed
#
# the design goal of ptest.pl is not to depend on anything specific.
# it does not need an instance of PhEDEx-Datasvc to run, so that it
# could be easily deployed to the test nodes, even through simple
# ssh/scp. All information are passed through command line.
# The command line arguments are:
#
# ptest.pl <start> <test_id> <url> <remote_host> <remote_port>
#
# where:
# <start>        the start time to run. all tests are scheduled to run
#                at the same start time, which is calculated by
#                perf_test.pl. the resolution is one second, which is
#                the error range.
# <test_id>      unique id generated by perf_test.pl to identify every
#                test
# <url>          url is the command
# <remote_host>  the host where perf_test.pl is running
# <remote_port>  with <remote_host> and <remote_port> ptest.pl knows
#                how to pass result back to perf_test.pl.
#
#
# the output is a hash flattened and sent back to perf_test.pl
#
# if the test failed, the result is:
#
# {status => "ERROR", message => "...."}
#
# otherwise, the result is:
#
# {
#   status => "OK",
#   message => "",
#   request_url => ".....",
#   request_date => ".....",
#   call_time => ...,
#   load =>
# }
#

use IO::Socket::INET;
use IO::File;
use XML::Simple;
use Data::Dumper;
use Sys::Hostname;
use Time::HiRes qw ( clock_gettime );	# use high resolution timer

my ($start, $test_id, $url, $remote_host, $remote_port) = @ARGV;

# just for debugging in development
#
# print "remote_host = ", $remote_host, "\n";
# print "remote_port = ", $remote_port, "\n";
# print "      start = ", $start, "\n";
# print "    test_id = ", $test_id, "\n";
# print "   test_cmd = ", $test_cmd, "\n";

my $xml = new XML::Simple;

# wait for start
while (time() < $start)
{
	sleep 1;
}

my %result = (
	id => $test_id,
	test_host => hostname(),
	pid => $$ );

# execute the command
my $t0 = clock_gettime();
my $fh = IO::File->new("wget -O - \"$url\" 2>/dev/null 1| ");

my $data = $xml->XMLin($fh);

$result{"ctime"}= clock_gettime() - $t0;

if (ref($data) ne "HASH")
{
	$result{"status"} = "ERROR";
	$result{"mesage"} = $data;
}
else
{
	$result{"status"} = "OK";
	$result{"message"} = "";
	$result{"request_url"} = $data->{"request_url"};
	$result{"request_date"} = $data->{"request_date"};
	$result{"call_time"} = $data->{"call_time"};
	open (f1, "/proc/loadavg");
        $result{"load"} = (split(" ", <f1>))[0];
	close f1;
}

# was it invoked remotely?

if ($remote_host)
{
	my $res = pack("(w/a*)*", %result);
	my $sock = new IO::Socket::INET (
		PeerAddr => $remote_host, 
		PeerPort => $remote_port,
		Proto => 'tcp' );
	die "Could not create socket ($remote_host:$remote_port): $!\n" unless $sock;

	print$sock $res;
}
else # print it to screen
{
	printf "%4d %20s %6d %6s %s %10.6f %10.6f %10.6f %s %s\n",
		$result{id},
		$result{test_host},
		$result{pid},
		$result{status},
		$result{request_date},
		$result{call_time},
		$result{ctime},
		$result{ctime} - $result{call_time},
		$result{load},
		$result{request_url};
}
